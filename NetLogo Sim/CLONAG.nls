;to CLONAG [Ab Ag Ngen n Beta]
;  ;if generationNo > maxGenerations [stop]
;  ;Generate or input the list of Ag's (mission scenarios) to be faced
;  ;pick an Ag from the list
;  ;;
;  ;; 2 Run the mission for each of the Ab's, generating a list of Fitnesses f
;  ;;
;  
;  let i 0
;  set M length Ag
;  let Abm n-values M [randomGeneCode] ;change the length of this, fill with zeros?
;  let fm n-values M [0] ;change the length of this, fill with zeros?
;  ;;
;  while [i < Ngen] [
;    let j 0
;    
;    while [j < M] [
;      ;;
;      let Agj item j Ag ;1
;      let fj affinity (Ab) (Agj) ;2
;      let Abjn select (n) (Ab) (fj) ;3
;      let fjn select (n) (fj) (fj) ;3B the shorter ordered fitness list, corresponding to the elements of Abjn
;      let Cj clone (Abjn) (Beta) (fjn) ;4
;      let fjCn clone (fjn) (Beta) (fjn) ;4B the cloned fitness list, corresponding to the elements of Cj
;      let Cjstar hypermut (Cj) (fjCn) ;5
;      let fjstar affinity (Cjstar) (Agj);6
;      let Abstar first select (1) (Cjstar) (fjstar);7
;      let fAbStar item (position Abstar Cjstar) fjstar ;7B the shorter fitness list corresponding to that of Abstar
;      if fAbStar >= (item j fm) [set Abm replace-item j Abm Abstar set fm replace-item j fm fAbStar]
;      set Ab rebuild (Ab) (Abm) ;8
;
;      
;      ;;
;      ;increment the counter
;      set j (j + 1)
;    ]
;    set i (i + 1)
;  ]
;end

to-report affinity [inputAb inputAg]
  let counter 0
  let numAbs length inputAb
  let affinityList []
  while [counter < numAbs] [
    let i 0
    let fitnessTemp 0
    while [i < noReps] [
      set fitnessTemp (fitnessTemp + modelRunCLONAG (item counter inputAb) (inputAg))
      ;set fitnessTemp geneSum (item counter inputAb) (inputAg)
      set i (i + 1)
    ]
    set affinityList lput (fitnessTemp / noReps) affinityList
    set counter (counter + 1)
  ]  
  report affinityList
end


to-report select [NoElements inputGeneList inputFitnessList]
  let counter 0
  let selectedList []
  while [counter < NoElements] [
   let currentIndex position item counter (reverse sort inputFitnessList) inputFitnessList
   set selectedList lput item currentIndex inputGeneList selectedList
   set counter (counter + 1) 
  ]
  report selectedList
end

to-report clone [inputGeneList inputBeta inputFitnessList]
  let i 0
  
  let outputCloneList []
  let numInputGenes length inputGeneList
  
  while [i < numInputGenes] [
   let numClones round ((inputBeta * numInputGenes) / (i + 1))
   let j 0
   while [j < numclones] [
    set outputCloneList lput (item i inputGeneList) outputCloneList
    set j (j + 1) 
   ] 
   set i (i + 1)
  ]
  
  report outputCloneList
end

to-report hypermut [inputGeneList inputFitnessList]
  let i 0
  let numInputGenes length inputGeneList
  let mutatedGeneList []
  
  while [i < numInputGenes] [
    let mutationFactor (((item i inputFitnessList) * 30) + 1)
    set mutatedGeneList lput (mutate (item i inputGeneList) (mutationFactor)) mutatedGeneList
    set i (i + 1)
  ]
  report mutatedGeneList
end

to-report rebuild [inputGeneList inputGeneMemoryList]
  let numInputGenes length inputGeneList
  let numInputMemoryGenes length inputGeneMemoryList
  let outputGeneList []
  let i 0
  
  while [i < numInputGenes] [
    ifelse i < numInputMemoryGenes [set outputGeneList lput item i inputGeneMemoryList outputGeneList][set outputGeneList lput randomGeneCode outputGeneList]
    
    set i (i + 1)
  ]
  report outputGeneList
end

to-report mutate [inputGeneList inputMutationRate]
  let pGeneFlip inputMutationRate
  let i 0
  let imax length inputGeneList - 1
  while [i < imax] [
    let j 0
    let jmax length item i inputGeneList - 1
    while [j < jmax] [
      if random pGeneFlip = 0 [ 
        let oldGene item i inputGeneList
        ifelse item j oldGene = 0 [set oldGene replace-item j oldGene 1][set OldGene replace-item j oldGene 0]
        set inputGeneList replace-item i inputGeneList oldGene
      ]
      set j (j + 1)
    ]
    set i (i + 1)
  ]
  report inputGeneList
end

  
;to-report geneSum [inputGene inputTest]
;  let i 0
;  let result 0
;  while [i < length inputGene] [
;    set result result + sum item i inputGene
;    set i (i + 1)
;  ]
;  ifelse inputTest = 1 [set result result][set result (1 / (result + 1))]
;  report result
;end